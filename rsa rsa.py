# 关于rsa加密
# (1)选择一对不同的、足够大的素数p,q。
# (2)计算n=pq。
# (3)计算f(n)=(p-1)(q-1),同时对p, q严加保密,不让任何人知道。
# (4)找一个与f(n)互质的数e,且1<e<f(n)。
# (5)计算d,使得de≡1 mod f(n)。这个公式也可以表达为d ≡e-1 mod f(n)
# 这里要解释一下,≡是数论中表示同余的符号。公式中,≡符号的左边必须和符号右边同余,也就是两边模运算结果相同。显而易见,不管f(n)取什么值,符号 右边1 mod f(n)的结果都等于1；符号的左边d与e的乘积做模运算后的结果也必须等于1。这就需要计算出d的值,让这个同余等式能够成立。
# (6)公钥KU=(e,n),私钥KR=(d,n)。
# (7)加密时,先将明文变换成0至n-1的一个整数M。若明文较长,可先分割成适当的组,然后再进行交换。设密文为C,则加密过程为：C≡M^e(mod n)。
# (8)解密过程为：M≡C^d(mod n)。

# p: 第一个大素数
# q: 第二个大素数 
# 模数n: p*q 
# f(n): (p-1)*(q-1) 
# 公钥指数e: 与 f(n)互质, 且 1 < e < f(n) 
# 私钥指数d: 满足e * d ≡ 1 (mod f(n))
# 公钥 = {n, e} 
# 私钥 = {d, e}

# e = 65537
# p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483
# q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407
# n = p*q
# #密文
# C = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034

# d = 56632047571190660567520341028861194862411428416862507034762587229995138605649836960220619903456392752115943299335385163216233744624623848874235303309636393446736347238627793022725260986466957974753004129210680401432377444984195145009801967391196615524488853620232925992387563270746297909112117451398527453977

# #求明文
# M = pow(C,d,n)    #快速求幂取模运算
# print(M)


#from __future__ import division
#---------------------------------------------------------------
#分解大整数
import math
 
#-------------------------------------
# 求欧拉函数f(n)
def getEuler(prime1, prime2):
    return (prime1-1)*(prime2-1)
#---------------------------------------------------------------------------------------
# 19d - 920071380k= 1
# 求私钥d
def getDkey(e, Eulervalue):#可以辗转相除法
	k = 1
	while True:
		if (((Eulervalue * k) + 1) % e) == 0:
			(d,m)=divmod(Eulervalue * k + 1,e)
			return d#避免科学计数法最后转int失去精度
		k += 1
#------------------------------------------------------
#求明文
def Ming(c,d,n):
	return pow(c,d,n)
#---------------------------------------------------------------------------------------
if __name__=='__main__':
	p=9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483
	q=11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407
	d=getDkey(65537,getEuler(p,q))
	print('key%d'%d)
	c=83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034
	n=p*q
	print('words')
	print(Ming(c,d,n))
	
	
 
 
 
 
 
 